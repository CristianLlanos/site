{
  "title": "SRP: El principio de una sola responsabilidad",
  "date": "2021-02-14T17:27:29.784Z",
  "description": "¿Cómo aplicar el Single Responsibility Principle? Desarrollaremos algunos consejos para aplicar este gran principio en nuestro código",
  "body": "## ¿Qué es SRP?\n\nHay muchas definiciones sobre este principio. La que más me gusta es:\n\n> Una entidad de software debe tener una sola razón para cambiar\n\n[Este principio](http://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) fue recopilado y documentado por Robert C. Martin junto a otros 4 con la finalidad de promover un \"código limpio\" al que haré referencia como *código mantenible* de aquí en adelante.\n\nEso es en cuando a la definición. No es muy detallada, ¿verdad?\n\nLo más interesante para mí ha sido entender cómo identificar que mi código está alejándose de este principio. Y hasta ahora lo he relacionado mucho con los conceptos de [**cohesión** y **acoplamiento**](https://stackoverflow.com/a/42188930/7062181).\n\n> **Cohesión**: el nivel de relación del código dentro un módulo\n>\n> **Acoplamiento**: el nivel de relación entre módulos\n\nEs conocido que, para producir un código mantenible, debemos aumentar la cohesión y disminuir el acoplamiento de nuestras entidades de software. Bajo esta idea, podríamos decir que un código altamente cohesionado es aquél que tiene una sola razón de cambio. Cuando nos acoplamos a alguna dependencia más de lo que es necesario, nuestra razón de cambio será ampliada y eso no es lo que queremos.\n\n## Ejemplo\n\nBueno, la teoría hace que todo parezca simple, así que mejor veamos algunos casos en los que se puede identificar que el código no está siguiendo el principio de una sola responsabilidad.\n\nEsto no se trata de criticar a ninguno de los proyectos a continuación, sino de mostrar que hay oportunidades de mejora. Sin embargo, el hecho de que algo pueda ser mejorado, no significa que debamos obsesionarnos con SRP y querer cambiarlo todo. Lo importante es ser conscientes de que se puede mejorar y en el momento apropiado, hacerlo.\n\n### BroadcastManager::routes() de Laravel\n\n```php\n<?php\n\n    // https://github.com/laravel/framework/blob/8.x/src/Illuminate/Broadcasting/BroadcastManager.php#L63\n\n    public function routes(array $attributes = null)\n    {\n        if ($this->app instanceof CachesRoutes && $this->app->routesAreCached()) {\n            return;\n        }\n\n        $attributes = $attributes ?: ['middleware' => ['web']];\n\n        $this->app['router']->group($attributes, function ($router) {\n            $router->match(\n                ['get', 'post'], '/broadcasting/auth',\n                '\\\\'.BroadcastController::class.'@authenticate'\n            )->withoutMiddleware([\\Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken::class]);\n        });\n    }\n```\n\nEn [la clase BroadcastManager](https://github.com/laravel/framework/blob/8.x/src/Illuminate/Broadcasting/BroadcastManager.php#L63) está definido el método `routes()` y aunque es muy útil para personalizar el framework a nuestras necesidades, tiene un código con muy baja cohesión con respecto a los demás métodos. Además está acoplando la clase al `router` y también a `VerifyCsrfToken`.\n\n¿Cómo es que he determinado esto?\n\nLa tarea principal de las clases con sufijo `Manager` dentro de Laravel es muy similar a la de un Factory. Estas clases se suelen encargar de la creación de objetos complejos que comparten una misma interfaz (todos implementan la misma interfaz `\\Illuminate\\Contracts\\Broadcasting\\Broadcaster`).\n\nAhora que sabemos para qué sirve esta clase, hablemos sobre su razón de cambio. ¿Cuándo deberíamos tener la necesidad de cambiar esta clase? ¡Exacto! Cuando queramos agregar una nueva implementación de `\\Illuminate\\Contracts\\Broadcasting\\Broadcaster` al sistema. Debido a que `routes()` no tiene que ver con eso, tiene una baja cohesión.\n\nSin embargo, al tener este método `routes()` tenemos una nueva razón de cambio. Cada vez que cambien las API del `router` (`group()` y `match()`), nos veremos obligados a venir a este archivo y cambiarlo también. Esto pasa porque nos hemos acoplado al `router` para lograr esta funcionalidad.\n\n¿Y cómo podríamos seguir el principio SRP y resolver este caso?\n\nPrimero hay que identificar qué entidad es la encargada de orquestar la relación entre módulos. ¿Alguna idea? Si pensaste en el `Contenedor de Dependencias`, estás en lo correcto. Pero no podemos ir directamente al contenedor de dependencias y agregar este código. En Laravel tenemos unos componentes llamados `Service Providers` que se encargan de nutrir al `Contenedor de dependencias`.\n\nCada paquete / módulo de Laravel tiene su propio Service Provider con las configuraciones de las instancias que expone el paquete. Este paquete también tiene su respectivo provider llamado `Illuminate\\Broadcasting\\BroadcastServiceProvider` y es ahí donde pondría este código. Pero ya no se podría recibir los $attributes por un método. Tendríamos que cambiar esto para que los atributos sean leídos de otra forma, por ejemplo, a través de un archivo de configuración.\n\nObservación\n\nHay muchas formas de interpretar el SRP y aquí he expuesto la forma en que he aprendido a verlo. También he dado una propuesta de solución pero no significa que sea la única forma de hacerlo. Estoy seguro de que hay muchas formas creativas y mantenibles de resolver este caso. Incluso dejarlo tal y como está está bien. El SRP es una guía, no es una ley.\n\n## Conclusión\n\nLa definición del SRP puede ser simple, pero sus implicancias en el código hacen que nos cuestionemos la ubicación de nuestro código. Podríamos resolver este principio extrayendo funcionalidad en un método, en una clase nueva, en un módulo nuevo, etc.\n\nLos invito a cuestionar estas ideas y construir software que cada vez sea más mantenible y con mejor calidad."
}